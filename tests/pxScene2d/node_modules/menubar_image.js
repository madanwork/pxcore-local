var px = require("../build/Debug/px");
var scene = px.getScene(0, 0, 1920, 1080);
var util = require('util');
var globals = require("globals");

	MenuBarImage.prototype.animateBlur = function(image) {
		console.log("animateBlur: focusIndx is "+this.focusIndx);
		console.log("animateBlur: image.y is "+image.y);
		console.log("animateBlur: image.x is "+image.x);

		image.animateTo({x:image.x,sx:1,sy:1},1.0, scene.PX_STOP, scene.PX_END);

	}

	MenuBarImage.prototype.animateFocus = function(image, lineTopFocus, lineBtmFocus) {
		

	image.animateTo({cx:image.w*this.posRatio,cy:image.h*this.posRatio,sx:this.focusRatio,sy:this.focusRatio},1.0, scene.PX_STOP, scene.PX_END);

	// This logic and calculation needs work!  Needs to work across all positions and image sizes				
	lineTopFocus.animateTo({x:image.x-(image.w*this.posRatio)/4,
						  y:image.y-((image.y*this.posRatio)/this.focusRatio),
						  w:image.w*this.focusRatio},
						  1.0, scene.PX_STOP, scene.PX_END);
	lineBtmFocus.animateTo({x:image.x-(image.w*this.posRatio)/4,
						  y:(image.y-((image.y*this.posRatio)/this.focusRatio))+(image.h*this.focusRatio),
						  w:image.w*this.focusRatio},
						  1.0, scene.PX_STOP, scene.PX_END);


							  
		image.moveToFront();					  
	}

function MenuBarImage(parentScene, name, x, y, w, h, imageItems) {

	this.name = name;
	this._scene = parentScene;
	this.imageUrls = [];
	this.imageItems = imageItems;
	

	this.imageUrls = imageItems;
	console.log("!!!!!!!!!!!!!!!!!!imageUrls is "+this.imageUrls);
	console.log("!!!!!!!!!!!!!!!!!!imageItems is "+imageItems);
	
	// member data               
	this.imageObjs = [];
	this.line;
	this.focusIndx = 0;
	this.focusColor = 0x0080c0ff;
	this.idleColor = 0xffffffaa;
	this.xPos=0;
	this.picWidth = 350;
	this.picPad = 5;
	this.picY = 75; // relative to container position
	this.focusRatio = 1.25;
	this.posRatio = .50;
	// use globals.gUrlStart for location of std images
	this.urlFocus = globals.gUrlStart + "focusMenuLine.png";
	this.lineTopFocus = null;
	this.lineBtmFocus = null;
	this.imageContainer = null;
	this.textTitle1 = null;
	this.line = null;
	this.defaultText = "Featured TV";
	console.log("creating Container in menubar_image_4_usingClass");
	this.container = scene.createImage({parent:this._scene, a:1, x:x, y:y, w:w, h:h, clip:false});


	/** 
	 * this.container: onFocus - Add focus lines and animate focused image to be larger
	 */
	this.container.on('onFocus', function(e) {
		console.log("onFocus received in "+this.name);

		var image = this.imageObjs[this.focusIndx];

		// Create images for focus lines
		console.log("creating lineTopFocus in menubar_image_4_usingClass");
		this.lineTopFocus = scene.createImage9({url:this.urlFocus,x:image.x,y:image.y-4,w:image.w,h:4,parent:this.container});
		console.log("creating lineBtmFocus in menubar_image_4_usingClass");
		this.lineBtmFocus = scene.createImage9({url:this.urlFocus,x:image.x,y:image.y+image.h,w:image.w,h:4,parent:this.container});
		 
		this.animateFocus(image, this.lineTopFocus, this.lineBtmFocus);
		
		// !CLF: Eventually, could/should focus be set to each individual image object? 

	}.bind(this));
	
	/** 
	 * this.container: onBlur - Remove focus lines and bring previously focused image back to normal size
	 */
	this.container.on('onBlur', function(e) {
		console.log("onBlur received in "+this.name);
		var image = this.imageObjs[this.focusIndx];
		if( this.lineTopFocus != null) {
			this.lineTopFocus.remove(); 
			this.lineTopFocus = null;
			this.lineBtmFocus.remove(); 
			this.lineBtmFocus = null;
		}	
		this.animateBlur(image);
	}.bind(this));

	/** 
	 * this.container: onKeyDown - Do navigation
	 */
	this.container.on('onKeyDown', function(e) {
	  if (e.keyCode == 40) { // down arrow
		 console.log("onKeyDown 40 (down arrow) received in menubar_image this.container for "+this.name);

	  } 
	  else if(e.keyCode == 38) { // up arrow
		  console.log("onKeyDown 38 (up arrow) received in menubar_image_4 this.container for "+this.name);
	  } 
	  // Handle left/right keys for navigation
	  else if( e.keyCode == 39 || e.keyCode == 37) {
		  if(e.keyCode == 39) { // right arrow
			  console.log("onKeyDown 39 (right arrow) received in menubar_image_4 this.container for "+this.name);
			  e.stopPropagation();
			  if( this.focusIndx < (this.imageObjs.length-1)) {
				  
				  // Check if we need to scroll
				  if( this.imageObjs[this.focusIndx+1].x +(this.focusRatio*this.imageObjs[this.focusIndx+1].w) > this.imageContainer.w) 
				  {
					  this.scrollRight();
				  }	

				  else {
					  // Scroll necessary yet
					  var image;
					  // animate image losing focus
					  image = this.imageObjs[this.focusIndx];		
					  this.animateBlur(image);
					  
					  this.focusIndx++;
					  // animate image gaining focus
					  image = this.imageObjs[this.focusIndx];

					  this.animateFocus(image, this.lineTopFocus, this.lineBtmFocus);
			       }
			  }
			 
		  } else if(e.keyCode == 37) { // left arrow
			  console.log("onKeyDown 37 (left arrow) received in menubar_image_4 this.container for "+this.name);
			  e.stopPropagation();
			  if( this.focusIndx > 0) {
				  // Check if we need to scroll
				  if( this.imageObjs[this.focusIndx-1].x < 0) {
					  this.scrollLeft();
				  } 
				  else {
					  // No scrolling necessary yet
					  var image;
					  image = this.imageObjs[this.focusIndx];	
					  this.animateBlur(image);
					  
					  this.focusIndx--;
					  image = this.imageObjs[this.focusIndx];	
					  this.animateFocus(image, this.lineTopFocus, this.lineBtmFocus);
					}
			  }
			}

				 
		  } else if(e.keyCode == 13) { // enter key
			  // !CLF: Need implementation for showing details of whatever image was selected
	  }
	}.bind(this)); // end this.container onKeyDown
	
	// Scene.root.on. We want our events to be handled in this.container.on, though (above)
	scene.root.on('onKeyDown', function(e) {
	  if (e.keyCode == 40) { // down arrow
		 console.log("onKeyDown 40 (down arrow) received in menuBarImage scene "+this.name);
		
	  } else if(e.keyCode == 38) { // up arrow
		  console.log("onKeyDown 38 (up arrow) received in menuBarImage scene "+this.name);
		 

	  } else if(e.keyCode == 39) { // right arrow
		  console.log("onKeyDown 39 (right arrow) received in menuBarImage scene "+this.name);

	  } else if(e.keyCode == 37) { // left arrow
		  console.log("onKeyDown 37 (left arrow) received in menuBarImage scene "+this.name);

	  } else if(e.keyCode == 13) { // enter key
		  // !CLF: Need implementation for showing details of whatever image was selected

	  }
	}.bind(this));

}


/**
 * setMenuItems - This function allows images shown to be replaced on the fly.
 * 				  It assumes no change to image positions/dimensions.
 */
MenuBarImage.prototype.setMenuItems = function(newText, newImageUrls) {
	// Clear old image values
	for( var i = 0; i < this.imageUrls.length; i++) {
		this.imageObjs[i].remove();
		this.imageObjs[i] = null;
	}	
	// create for new images
	this.imageItems = newImageUrls;
	this.imageUrls = newImageUrls;
	
	this.xPos = 0;
	this.textTitle1.text = newText;
	this.showMenu();
}
/**
 * showMenu() - this is the main functionality for this js
 */
MenuBarImage.prototype.showMenu = function() {

	// Clean up old line since we're drawing/redrawing with new images
	if( this.line != null) {
		this.line.remove();
		this.line = null;
	}
	console.log("MenuBarImage showMenu() function");
	// Create titles
	if( this.textTitle1 == null) {
		this.textTitle1 = scene.createText({text:this.defaultText,
							parent:this.container,
							x:0,
							y:0, 
							textColor:this.idleColor,
							pixelSize:30});
	}
	
	// Create array of image objects for row 1
	console.log("creating imageContainer in menubar_image_4_usingClass");
	this.imageContainer = scene.createScene({parent:this.container, x:0, y:0,w:1255, a:1, h:this.container.h});

	var picture = null;
	console.log("imageUrls.length is "+this.imageUrls.length);
	for( var i = 0; i < this.imageUrls.length; i++) {

	    console.log("current image is "+this.imageUrls[i]);

	    //var url = globals.gUrlStart+this.imageItems[i];
	    //console.log("url for image is "+url);
	   
	    picture = scene.createImage({url:this.imageItems[i], parent:this.imageContainer, x:this.xPos, a:1, y:this.picY});
	    this.xPos+= this.picWidth + this.picPad;
	    this.imageObjs[i] = picture;
	    	   
	    this.imageObjs[i].ready.then(function(picture) { 
	
			picture.sx = this.picWidth/picture.w;
			picture.sy = this.picHeight/picture.h;
		
			//console.log("Picture w and h are "+picture.w+" "+picture.h);
			//console.log("Picture x and y are "+picture.x+" "+picture.y);
			picture.animateTo({x:picture.x,sx:1,sy:1},1.0, scene.PX_STOP, scene.PX_END);});

		}

	// Create image divider line based on position/height of last picture
	
	//var urlLine = process.cwd() + "/../../images/grayMenuLine.png";
	var urlLine = globals.gUrlStart+"grayMenuLine.png";
	console.log("creating urlLine in menubar_image_4_usingClass");
	if( this.line == null) {
		// Workaround because createImage9 does not respect h or w sent in constructor. Save off
		// "this" stuff so can use in ready.then function
		var width = this.container.w;
		var tempContainer = this.container;
		var tempImageContainer = this.imageContainer;
		var tempRatio = this.focusRatio;
		picture = this.imageObjs[this.focusIndx];
		this.line	= scene.createImage9({url:urlLine,a:1, x:0,y:picture.y+(this.picHeight*this.focusRatio)+10,h:2,w:this.container.w,parent:this.container});  
		this.line.ready.then( function(image) {
			image.w = width;
			image.h = 2;
			tempContainer.h = image.y+image.h;
			tempImageContainer.h = picture.h*tempRatio;		
		});
	}
}

/**
 * scrollRight
 */
MenuBarImage.prototype.scrollRight = function()  {
	console.log("scrollRight");
	var image;

	this.focusIndx++;
	// animate image gaining focus
	image = this.imageObjs[this.focusIndx];					  
	// Shift all images to the left
	image.x = this.imageContainer.w - (this.focusRatio*this.picWidth);

	this.xPos = this.imageObjs[this.focusIndx-1].x;
	console.log("imageObjs[]0.x is "+this.imageObjs[0].x);
	for( var i = this.focusIndx-1; i >= 0; i--) {
	  var tempImage = this.imageObjs[i];
	  
	  //this.animateBlur(tempImage);
	  if( i == this.focusIndx-1) {
		this.xPos -= (this.picWidth+this.picPad); //*this.posRatio);
		// calc backward from tempImage.x curr pos
		tempImage.x = this.xPos;//(this.picWidth+this.picPad)*this.posRatio;
		this.animateBlur(tempImage);
		
	  } 
	  else {

		this.xPos -= (this.picWidth+this.picPad);  
		// calc backward from tempImage.x curr pos
		tempImage.x = this.xPos;//(this.picWidth+this.picPad);
		tempImage.animateTo({x:this.xPos},1.0, scene.PX_STOP, scene.PX_END);
		}
	}
	this.animateFocus(image, this.lineTopFocus, this.lineBtmFocus);
}
/**
 * scrollLeft
 */
MenuBarImage.prototype.scrollLeft = function() {
	console.log("scrollLeft");
	var image;

	  
	this.focusIndx--;
	// animate image gaining focus
	image = this.imageObjs[this.focusIndx];					  
	// Shift all images to the left
	image.x = 0;

	this.xPos = 0;
	console.log("imageObjs[]0.x is "+this.imageObjs[0].x);
	for( var i = this.focusIndx+1; i < this.imageObjs.length; i++) {
	  var tempImage = this.imageObjs[i];
	  
	  if( i == this.focusIndx+1) {
		this.xPos += (this.picWidth+this.picPad);//*this.posRatio;
		// calc forward from tempImage.x curr pos
		tempImage.x = this.xPos;//(this.picWidth+this.picPad)*this.posRatio;
		this.animateBlur(tempImage);

	  } 
	  else {

		this.xPos += (this.picWidth+this.picPad);  
		// calc forward from tempImage.x curr pos
		tempImage.x = this.xPos;//(this.picWidth+this.picPad);
		tempImage.animateTo({x:this.xPos},1.0, scene.PX_STOP, scene.PX_END);
		}
		
	}
	this.animateFocus(image, this.lineTopFocus, this.lineBtmFocus);

} 


module.exports = MenuBarImage;
