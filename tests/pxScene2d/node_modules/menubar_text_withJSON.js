var px = require("../build/Debug/px");
var scene = px.getScene(0, 0, 1920, 1080);

var MenuBarImage = require("menubar_image_withJSON");
var globals = require("globals");

// URL to use for locating images for lines, focus lines and arrows
//var urlstart = "http://127.0.0.1/XRE2/XREImages/";

console.log("globals.gUrlStart in OnDemand is "+globals.gUrlStart);


function MenuBarText(parentScene, name, x, y, w, h, menuData) {
	this.name = name;
	this._scene = parentScene;
	this.menuData = menuData;
	//this.textItems = textItems;
	
	// Images to use as we navigate
	this.urlFocus = globals.gUrlStart+"focusMenuLine.png";
	this.urlLine = globals.gUrlStart+ "grayMenuLine.png";
	this.urlRightArrow = globals.gUrlStart+ "rightArrowGradient_7.png";
	this.urlLeftArrow = globals.gUrlStart+ "leftArrowGradient.png";	
	//this.urlFocus = process.cwd() + "/../../images/focusMenuLine.png";
	//this.urlLine = process.cwd() + "/../../images/grayMenuLine.png";
	//this.urlRightArrow = process.cwd() + "/../../images/rightArrowGradient_7.png";
	//this.urlLeftArrow = process.cwd() + "/../../images/leftArrowGradient.png";
	
	this.textObjs = [];
	this.focusIndx = 0;
	this.focusColor = 0x0080c0ff;
	this.idleColor = 0xffffffaa;
	this.xPos=0;
	this.pad = 30;
	this.arrowWidth=50;
	this.arrowOverlap=0;//arrowWidth*.25;
	
	this.container = scene.createImage({parent:this._scene, x:25, y:25, w:w, h:h, a:1,clip:true});

	this.y = y;
	this.w = w;
	this.textHeight = 40;
	
	this.menuBarImage = null;

	this.myFocusedWidget = null;
	
	this.lineTopFocus = null;
	this.lineBtmFocus = null;
	/** 
	 * onKeyDown handler: handle right and left arrow keys to move
	 * focus across the menu
	 */
	this.container.on('onKeyDown', function(e) {
		console.log("onKeyDown " + e.keyCode+ " received in this.container for "+this.name);
		//console.log("onKeyDown target is "+e.target);
		//console.log("My container is "+this.container);

		if( e.keyCode == 39 || e.keyCode == 37) {
			e.stopPropagation();
			this.textObjs[this.focusIndx].textColor = this.idleColor;
			  if (e.keyCode == 39) { // right arrow
				if( this.focusIndx < (this.textObjs.length-1)) {
					this.focusIndx++;
					this.menuBarImage.focusIndx = 0;
					this.menuBarImage2.focusIndx = 0;
					this.menuBarImage3.focusIndx = 0;
				} 
		 
			  } else if(e.keyCode == 37 ) { // left arrow
				  if( this.focusIndx > 0) {
					  this.focusIndx--;
					this.menuBarImage.focusIndx = 0;
					this.menuBarImage2.focusIndx = 0;
					this.menuBarImage3.focusIndx = 0;					  
				  } 
		
			  }
		
			  this.lineTopFocus.w = this.textObjs[this.focusIndx].w;
			  this.lineBtmFocus.w = this.textObjs[this.focusIndx].w;
			  if( this.textObjs[this.focusIndx] != null) {
				  this.textObjs[this.focusIndx].textColor = this.focusColor;
			  }
		      
		      console.log("onkey");
		      console.log("textObjs[this.focusIndx].x "+this.textObjs[this.focusIndx].x);
		      console.log("this.focusIndx == "+this.focusIndx);
		
		
			  if( (this.textObjs[this.focusIndx].x + this.textObjs[this.focusIndx].w) > this.container.w) {
				  var xVal = this.scrollRight();
				  this.lineTopFocus.animateTo({x:xVal},0.3, scene.PX_STOP, scene.PX_END);
				  this.lineBtmFocus.animateTo({x:xVal},0.3, scene.PX_STOP, scene.PX_END);		  
			  } else if( this.textObjs[this.focusIndx].x < 0){
				  var xVal = this.scrollLeft();
				  this.lineTopFocus.animateTo({x:xVal},0.3, scene.PX_STOP, scene.PX_END);
				  this.lineBtmFocus.animateTo({x:xVal},0.3, scene.PX_STOP, scene.PX_END);
			  } else {
				  this.lineTopFocus.animateTo({x:this.textObjs[this.focusIndx].x},0.3, scene.PX_STOP, scene.PX_END);
				  this.lineBtmFocus.animateTo({x:this.textObjs[this.focusIndx].x},0.3, scene.PX_STOP, scene.PX_END);
			  }
			  // Set child images to show
			  console.log("subtitle 1 is "+this.menuData.menu[this.focusIndx].imageMenus[1].subTitle);
			  this.menuBarImage.setMenuItems(this.menuData.menu[this.focusIndx].imageMenus[0].subTitle, this.menuData.menu[this.focusIndx].imageMenus[0].images);
			  this.menuBarImage2.setMenuItems(this.menuData.menu[this.focusIndx].imageMenus[1].subTitle, this.menuData.menu[this.focusIndx].imageMenus[1].images);
			  this.menuBarImage3.setMenuItems(this.menuData.menu[this.focusIndx].imageMenus[2].subTitle, this.menuData.menu[this.focusIndx].imageMenus[2].images);
		} 
		  else if (e.keyCode == 40) { // down arrow
				if( this.myFocusedWidget === this.menuBarImage.container) {
					
					this.container.animateTo({y:-this.menuBarImage2.container.y+25},1.0, scene.PX_STOP, scene.PX_END);
					
					scene.setFocus(this.menuBarImage2.container);
					this.myFocusedWidget = this.menuBarImage2.container;
				} else if( this.myFocusedWidget === this.menuBarImage2.container) {
					
					this.container.animateTo({y:-this.menuBarImage3.container.y+25},1.0, scene.PX_STOP, scene.PX_END);
					
					scene.setFocus(this.menuBarImage3.container);
					this.myFocusedWidget = this.menuBarImage3.container;
				} else if( this.myFocusedWidget == this.container) {
					// !CLF: TO DO:  This is a workaround because this widget does 
					// not seem to be getting the expected OnBlur when it sets focus to 
					// the other widgets.  Is the mFocus in pxScene not set properly for
					// some reason, so that this widget isn't getting OnBlur???			
					// Begin workaround
					if( this.lineTopFocus != null) {
						this.lineTopFocus.remove(); 
						this.lineTopFocus = null;
						this.lineBtmFocus.remove(); 
						this.lineBtmFocus = null;
					}			
					// End workaround	
					
					// Animate menu upwards
				   this.container.animateTo({y:-(this.lineBtm.y)},1.0, scene.PX_STOP, scene.PX_END);//.then(function(){

				  scene.setFocus(this.menuBarImage.container);
				  this.myFocusedWidget = this.menuBarImage.container;
			    }

   
		  } else if(e.keyCode == 38) { // up arrow
			
			if( this.myFocusedWidget === this.menuBarImage.container) {
			  this.container.animateTo({y:25},0.3, scene.PX_STOP, scene.PX_END);
			  scene.setFocus(this.container);
			  this.myFocusedWidget = this.container;
			} 
			else if( this.myFocusedWidget === this.menuBarImage2.container) {
			  this.container.animateTo({y:-(this.lineBtm.y)},1.0, scene.PX_STOP, scene.PX_END);
			  scene.setFocus(this.menuBarImage.container);
			  this.myFocusedWidget = this.menuBarImage.container;
			}
			else if( this.myFocusedWidget === this.menuBarImage3.container) {
			  this.container.animateTo({y:-this.menuBarImage2.container.y+25},1.0, scene.PX_STOP, scene.PX_END);
			  scene.setFocus(this.menuBarImage2.container);
			  this.myFocusedWidget = this.menuBarImage2.container;
			}		
		
		  } 		
	      
	}.bind(this));

	this.container.on('onFocus', function(e) {
		console.log("onFocus received in  this.container "+this.name);

		// Should always be null after first load
		if( this.lineTopFocus == null) {
			var topY = this.y;
			var bottomY = this.y + this.h;
			var testingX = this.textObjs[this.focusIndx].x;
			var testingW = this.textObjs[this.focusIndx].w;

			this.lineTopFocus = scene.createImage9({url:this.urlFocus,x:this.textObjs[this.focusIndx].x,y:topY,w:this.textObjs[this.focusIndx].w,h:4,parent:this.container});
			this.lineBtmFocus = scene.createImage9({url:this.urlFocus,x:this.textObjs[this.focusIndx].x,y:bottomY-2,w:this.textObjs[this.focusIndx].w,h:4,parent:this.container});
			this.lineTopFocus.ready.then(function(image) {
				image.w = testingW;
				image.x = testingX;
				image.h = 4;
			});
			this.lineBtmFocus.ready.then(function(image) {
				image.w = testingW;
				image.x = testingX;
				image.h = 4;
			});

		} 

		this.textObjs[this.focusIndx].textColor = this.focusColor;
	}.bind(this));

	this.container.on('onBlur', function(e) {
		console.log("onBlur received in this.container "+this.name);
		if( this.lineTopFocus != null) {
			this.lineTopFocus.remove(); 
			this.lineTopFocus = null;
			this.lineBtmFocus.remove(); 
			this.lineBtmFocus = null;
		}

	}.bind(this));


}

MenuBarText.prototype.getContainer = function() { return this.container;};

// TO DO: Sort out these parms as compared to constructor parms. It's a mess.
MenuBarText.prototype.showMenu = function(x, y) {

	console.log("container.w is "+this.container.w);
	//console.log("root.w is "+this.root.w);
	//console.log("scene.w is "+this._scene.w);
	this.container.x = x;
	this.container.y = y;
	// Calculate x/y for the menu lines

	var topY = this.y;
	var bottomY = this.y + this.h;
	var textTopY = this.y +(this.h/2);
	textTopY -= (this.textHeight*.80); // add 5 for pad - make configurable
	//Create images to use for menu idle and focus lines
	this.lineTop = scene.createImage9({url:this.urlLine,x:0,y:topY,h:2,w:this.container.w,parent:this.container});
	this.lineTop.ready.then(function(image) {
		image.h=2;
		image.w=image.parent.w;//this.container.w;
	});
	this.lineBtm	= scene.createImage9({url:this.urlLine,x:0,y:bottomY,h:2,w:this.container.w,parent:this.container});  
	this.lineBtm.ready.then(function(image) {
		image.h=2;
		image.w=image.parent.w;//this.container.w;
	});

	// Create "children" image menu bars.
	// TO DO: Ideally, these would be created based on passed in data, added to a container, 
	// and navigation would be managed by passing focus back and forth between items
	// in the container.
	// TO DO: These child container positions/sizes should be from config file...
	// TO DO: Should create these based on each elem in this.menuData.menu[this.focusIndex].imageMenus
	console.log("images from JSON: "+this.menuData.menu[0]);
	this.menuBarImage = new MenuBarImage(this.container, "imageMenuBar", 25, 135, 1255, 600, this.menuData.menu[0].imageMenus[0].subTitle, this.menuData.menu[0].imageMenus[0].images);
	this.menuBarImage.picWidth = 350;
	this.menuBarImage.picHeight = 197;
	this.menuBarImage.showMenu();
	
	// Vertical image bar
	this.menuBarImage2 = new MenuBarImage(this.container, "imageMenuBar2", 25, 500, 1255,600, this.menuData.menu[0].imageMenus[1].subTitle, this.menuData.menu[0].imageMenus[1].images);
	this.menuBarImage2.picWidth = 127;
	this.menuBarImage2.picHeight = 184;
	this.menuBarImage2.picPad = 10;
	this.menuBarImage2.showMenu();
	
	// Next horizontal image bar
	this.container.h = 2000;
	this.menuBarImage3 = new MenuBarImage(this.container, "imageMenuBar3", 25, 865, 1255, 600, this.menuData.menu[0].imageMenus[2].subTitle, this.menuData.menu[0].imageMenus[2].images);
	this.menuBarImage3.picWidth = 350;
	this.menuBarImage3.picHeight = 197;
	this.menuBarImage3.showMenu();	
		
	// Create text to be shown in menu; text is coming from text array.  
	// This could come from database, too, to make variable and/or allow for different languages
//	console.log("textItems are "+this.textItems);
	for( var i = 0; i < this.menuData.menu.length; i++){//textItems.length; i++){
		var t = scene.createText({text:this.menuData.menu[i].title,
				parent:this.container,
				x:this.xPos,
				y:textTopY,
				textColor:this.idleColor,
				pixelSize:this.textHeight});

		// Increment xPos for position of next text item
		this.xPos+=t.w + this.pad;
		this.textObjs[i] = t; // store text object in array
	
		// If there are more text items than will fit on screen, create right arrow
		if((this.textObjs[i].x + this.textObjs[i].w) > this.container.w) {
			// Calculate where to put the arrow - need an image with gradient background
			if( this.arrowRight == null) {
				this.arrowRight = scene.createImage({url:this.urlRightArrow,x:(this.container.w-this.arrowWidth-this.arrowOverlap),
						y:textTopY+(this.textHeight*.25),parent:this.container,w:this.arrowWidth,h:this.textHeight, autoScale:true});
				this.arrowRight.sx = this.arrowWidth/this.arrowRight.w;
				this.arrowRight.sy = this.textHeight/this.arrowRight.h;
			}

		}
	
	}

	this.myFocusedWidget = this.container;

};

/*
 * Testing Hiding entire menu
MenuBarText.prototype.hideMenu = function() {
	for( var i = 0; i < this.textItems.length; i++){
		if( this.textObjs[i] !== null) {
			this.textObjs[i].remove();
			this.textObjs[i] = null;
		}
	}
}
*/



/**
 * scrollRight
 */
MenuBarText.prototype.scrollRight = function()  {
	console.log("scrollRight");
	var rtn;
	
	// Start at edge and animate objects out from there
	if( this.focusIndx == this.textObjs.length-1) {
		// set initial x position for objects
		rtn = this.container.w - this.textObjs[this.focusIndx].w;
		this.xPos = this.container.w;
		// remove arrow from the screen
		if( this.arrowRight != null) {
			this.arrowRight.remove();
			this.arrowRight = null;
		}
	} else {
		// Leave room for the arrow
		rtn = this.container.w - this.textObjs[this.focusIndx].w - this.arrowWidth;
		this.xPos = this.container.w - this.arrowWidth;
	}

	for( var i = this.focusIndx; i >= 0; i--) {
		this.xPos -= this.textObjs[i].w;
		this.textObjs[i].animateTo({x:this.xPos},0.3, scene.PX_STOP, scene.PX_END);
		this.xPos-= this.pad;
	}

	// Calculate if/where to put the left arrow since we now can scroll that direction
	console.log("left arrow calc: textobjx[0].x="+this.textObjs[0].x);
	if( this.arrowLeft == null &&  this.textObjs[0].x <= 0){
		console.log("creating left arrow");
		var textTopY = this.y +(this.h/2);//(bottomY-topY)/2;
		textTopY -= (this.textHeight*.80); // add 5 for pad - make configurable
		this.arrowLeft = scene.createImage({url:this.urlLeftArrow,x:0,
				y:textTopY+(this.textHeight*.25),parent:this.container,w:this.arrowWidth,h:this.textHeight, autoScale:true});
		this.arrowLeft.sx = this.arrowWidth/this.arrowLeft.w;
		this.arrowLeft.sy = this.textHeight/this.arrowLeft.h;
	}

	return rtn;
} 
/**
 * scrollLeft
 */
MenuBarText.prototype.scrollLeft = function() {
	console.log("scrollLeft");
	var rtn = 0;
	// Start at edge and animate objects out from there
	var w = this.textObjs[this.focusIndx].w;
	if( this.focusIndx == 0) {
		this.xPos = 0;
	} else {
		this.xPos = this.arrowWidth;
	}
	rtn = this.xPos;
	for( var i = this.focusIndx; i < this.textObjs.length; i++){
		this.textObjs[i].animateTo({x:this.xPos},0.3, scene.PX_STOP, scene.PX_END);
		this.xPos+=this.textObjs[i].w + this.pad;
	}
	if(this.focusIndx == 0) {
		if( this.arrowLeft != null) {
			this.arrowLeft.remove();
			this.arrowLeft = null;
		}
	}
	// Determine if it's time to show the right arrow yet
	var lasttextObj = this.textObjs[this.textObjs.length-1];
	if((lasttextObj.x+lasttextObj.w) >= this.container.w) {
		if( this.arrowRight == null) {
			var textTopY = this.y +(this.h/2);//(bottomY-topY)/2;
			textTopY -= (this.textHeight*.80); // add 5 for pad - make configurable
			this.arrowRight = scene.createImage({url:this.urlRightArrow,x:(this.container.w-this.arrowWidth-this.arrowOverlap),
					y:textTopY+(this.textHeight*.25),parent:this.container,w:this.arrowWidth,h:this.textHeight,autoScale:true});
			this.arrowRight.sx = this.arrowWidth/this.arrowRight.w;
			this.arrowRight.sy = this.textHeight/this.arrowRight.h;
		}
	}

	return rtn;
} 


module.exports = MenuBarText;
